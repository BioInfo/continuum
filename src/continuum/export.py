"""Export generation for Continuum."""

from datetime import datetime, timedelta
from pathlib import Path

from .config import Config


def generate_export(config: Config) -> str:
    """
    Generate the full export for Claude Code.

    Merges global and project-level context:
    - Identity: project overrides global
    - Voice: project overrides global
    - Context: project appends to global
    - Memory: project appends to global
    """
    now = datetime.now()

    # Build source info
    sources = [str(config.base_path)]
    if config.has_project:
        sources.append(str(config.project_path))

    parts = [
        "<!-- Continuum Export -->",
        f"<!-- Generated: {now.isoformat()} -->",
        f"<!-- Sources: {', '.join(sources)} -->",
        "<!-- Refresh: continuum export -->",
        "",
        "# User Context",
        "",
    ]

    # Identity (condensed) - project overrides global
    identity_path = config.project_identity_path or (
        config.identity_path if config.identity_path.exists() else None
    )
    if identity_path:
        identity = identity_path.read_text()
        parts.append("## Identity")
        parts.append("")
        parts.append(condense_content(identity, config.identity_max_words))
        parts.append("")

    # Voice (full) - project overrides global
    voice_path = config.project_voice_path or (
        config.voice_path if config.voice_path.exists() else None
    )
    if voice_path:
        voice = voice_path.read_text()
        parts.append("## Voice & Communication Style")
        parts.append("")
        parts.append(voice.strip())
        parts.append("")

    # Context (full) - merge global + project
    context_parts = []
    if config.context_path.exists():
        context_parts.append(config.context_path.read_text().strip())
    if config.project_context_path:
        context_parts.append(config.project_context_path.read_text().strip())

    if context_parts:
        parts.append("## Current Context")
        parts.append("")
        parts.append("\n\n---\n\n".join(context_parts))
        parts.append("")

    # Memory (filtered) - merge global + project
    memory_texts = []
    if config.memory_path.exists():
        memory_texts.append(config.memory_path.read_text())
    if config.project_memory_path:
        memory_texts.append(config.project_memory_path.read_text())

    if memory_texts:
        combined_memory = "\n\n".join(memory_texts)
        filtered_memory = filter_recent_memory(
            combined_memory, config.memory_recent_days, config.memory_max_entries
        )
        if filtered_memory.strip():
            parts.append("## Relevant Memory")
            parts.append("")
            parts.append(filtered_memory)
            parts.append("")

    parts.append("---")
    parts.append("*Generated by [Continuum](https://github.com/BioInfo/continuum)*")

    return "\n".join(parts)


def condense_content(content: str, max_words: int) -> str:
    """
    Condense content to approximately max_words.

    Tries to preserve structure by keeping headers and key sections.
    """
    lines = content.strip().split("\n")
    result_lines = []
    word_count = 0

    for line in lines:
        line_words = len(line.split())

        # Always include headers
        if line.startswith("#"):
            result_lines.append(line)
            word_count += line_words
            continue

        # Stop if we've exceeded the limit (but finish current section)
        if word_count + line_words > max_words:
            # If we're mid-section, add ellipsis
            if result_lines and not result_lines[-1].startswith("#"):
                result_lines.append("")
            break

        result_lines.append(line)
        word_count += line_words

    return "\n".join(result_lines)


def filter_recent_memory(content: str, days: int, max_entries: int) -> str:
    """
    Filter memory entries to recent ones.

    Returns entries from the last `days` days, or `max_entries`, whichever is more.
    """
    lines = content.strip().split("\n")
    entries = []
    header_lines = []
    cutoff_date = datetime.now() - timedelta(days=days)

    in_header = True
    for line in lines:
        # Detect header section (before entries)
        if in_header:
            if line.strip().startswith("[") and "]" in line:
                in_header = False
            else:
                if line.strip() and not line.strip().startswith("---"):
                    header_lines.append(line)
                continue

        # Parse entry
        if line.strip().startswith("["):
            try:
                # Extract date from [YYYY-MM-DD] or [YYYY-MM] format
                bracket_content = line[line.index("[") + 1 : line.index("]")]
                date_str = bracket_content.strip()

                # Parse various date formats
                entry_date = None
                for fmt in ["%Y-%m-%d", "%Y-%m"]:
                    try:
                        entry_date = datetime.strptime(date_str, fmt)
                        break
                    except ValueError:
                        continue

                if entry_date:
                    entries.append((entry_date, line.strip()))
            except (ValueError, IndexError):
                # Include malformed entries at the end
                entries.append((datetime.min, line.strip()))
        elif line.strip():
            # Continuation of previous entry or standalone line
            if entries:
                date, text = entries[-1]
                entries[-1] = (date, text + "\n" + line.strip())

    # Sort by date descending
    entries.sort(key=lambda x: x[0], reverse=True)

    # Filter: keep entries within date range OR up to max_entries
    filtered = []
    for date, text in entries:
        if date >= cutoff_date or len(filtered) < max_entries:
            filtered.append(text)

    if not filtered:
        return ""

    return "\n".join(filtered)


def write_export(config: Config, output_path: Path | None = None) -> Path:
    """Generate and write export to file."""
    content = generate_export(config)

    if output_path is None:
        config.exports_path.mkdir(parents=True, exist_ok=True)
        output_path = config.exports_path / "claude-code.md"

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(content)

    return output_path
